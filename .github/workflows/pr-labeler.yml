name: PR Auto Labeler

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  label-pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
    - name: Auto Label PR
      uses: actions/github-script@v6
      with:
        script: |
          const { owner, repo, number } = context.pullRequest;
          const pr = context.payload.pull_request;
          
          // PR íŒŒì¼ ë³€ê²½ì‚¬í•­ ê°€ì ¸ì˜¤ê¸°
          const { data: files } = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: number
          });
          
          let labels = [];
          
          // íŒŒì¼ ê²½ë¡œ ê¸°ë°˜ ë¼ë²¨ í• ë‹¹
          const hasBackendChanges = files.some(file => file.filename.startsWith('backend/'));
          const hasFrontendChanges = files.some(file => file.filename.startsWith('frontend/'));
          const hasTestChanges = files.some(file => file.filename.includes('test'));
          const hasDocsChanges = files.some(file => 
            file.filename.startsWith('docs/') || 
            file.filename.endsWith('.md') ||
            file.filename.endsWith('.rst')
          );
          const hasConfigChanges = files.some(file => 
            file.filename.includes('requirements.txt') ||
            file.filename.includes('.yml') ||
            file.filename.includes('.yaml') ||
            file.filename.endsWith('.json') ||
            file.filename.includes('Dockerfile')
          );
          
          // ì˜ì—­ë³„ ë¼ë²¨
          if (hasBackendChanges) labels.push('area/backend');
          if (hasFrontendChanges) labels.push('area/frontend');
          if (hasTestChanges) labels.push('area/testing');
          if (hasDocsChanges) labels.push('area/documentation');
          if (hasConfigChanges) labels.push('area/configuration');
          
          // PR ì œëª© ê¸°ë°˜ íƒ€ì… ë¼ë²¨
          const title = pr.title.toLowerCase();
          
          if (title.includes('[feat]') || title.includes('feat:') || title.includes('feature')) {
            labels.push('type/feature');
          } else if (title.includes('[fix]') || title.includes('fix:') || title.includes('bug')) {
            labels.push('type/bug');
          } else if (title.includes('[docs]') || title.includes('docs:') || title.includes('documentation')) {
            labels.push('type/documentation');
          } else if (title.includes('[refactor]') || title.includes('refactor:')) {
            labels.push('type/refactoring');
          } else if (title.includes('[test]') || title.includes('test:')) {
            labels.push('type/testing');
          } else if (title.includes('[chore]') || title.includes('chore:')) {
            labels.push('type/maintenance');
          } else if (title.includes('[style]') || title.includes('style:')) {
            labels.push('type/style');
          }
          
          // PR ë³€ê²½ ë¼ì¸ ìˆ˜ ê¸°ë°˜ í¬ê¸° ë¼ë²¨
          let totalChanges = 0;
          files.forEach(file => {
            totalChanges += file.additions + file.deletions;
          });
          
          if (totalChanges < 10) {
            labels.push('size/XS');
          } else if (totalChanges < 30) {
            labels.push('size/S');
          } else if (totalChanges < 100) {
            labels.push('size/M');
          } else if (totalChanges < 500) {
            labels.push('size/L');
          } else {
            labels.push('size/XL');
          }
          
          // ìš°ì„ ìˆœìœ„ ë¼ë²¨ (ì œëª©ì´ë‚˜ ì„¤ëª…ì—ì„œ í‚¤ì›Œë“œ ê²€ìƒ‰)
          const description = (pr.body || '').toLowerCase();
          const fullText = (title + ' ' + description).toLowerCase();
          
          if (fullText.includes('urgent') || fullText.includes('hotfix') || fullText.includes('critical')) {
            labels.push('priority/high');
          } else if (fullText.includes('breaking') || fullText.includes('breaking change')) {
            labels.push('priority/high');
            labels.push('breaking-change');
          }
          
          // ë“œë˜í”„íŠ¸ PRì¸ ê²½ìš°
          if (pr.draft) {
            labels.push('status/draft');
          } else {
            labels.push('status/ready-for-review');
          }
          
          // ì¤‘ë³µ ì œê±°
          labels = [...new Set(labels)];
          
          try {
            // ë¼ë²¨ ì ìš©
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: number,
                labels: labels
              });
              
              console.log(`ë¼ë²¨ ì ìš©ë¨: ${labels.join(', ')}`);
              
              // ë¼ë²¨ ì ìš© ê²°ê³¼ ëŒ“ê¸€
              const comment = `ğŸ·ï¸ **ìë™ ë¼ë²¨ë§ ì™„ë£Œ**
              
              ì ìš©ëœ ë¼ë²¨: ${labels.map(label => `\`${label}\``).join(', ')}
              
              **ğŸ“Š ë³€ê²½ í†µê³„:**
              - ì´ ë³€ê²½ ë¼ì¸ ìˆ˜: ${totalChanges}
              - ë³€ê²½ëœ íŒŒì¼ ìˆ˜: ${files.length}
              
              **ğŸ” ê°ì§€ëœ ì˜ì—­:**
              ${hasBackendChanges ? '- ğŸ”§ ë°±ì—”ë“œ' : ''}
              ${hasFrontendChanges ? '- ğŸ¨ í”„ë¡ íŠ¸ì—”ë“œ' : ''}
              ${hasTestChanges ? '- ğŸ§ª í…ŒìŠ¤íŠ¸' : ''}
              ${hasDocsChanges ? '- ğŸ“š ë¬¸ì„œ' : ''}
              ${hasConfigChanges ? '- âš™ï¸ ì„¤ì •' : ''}`;
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: comment
              });
            }
            
          } catch (error) {
            console.error('ë¼ë²¨ë§ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: number,
              body: `âš ï¸ ìë™ ë¼ë²¨ë§ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\nì˜¤ë¥˜: ${error.message}`
            });
          } 